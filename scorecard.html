---
layout: default
title: Matlock's Scorecard
permalink: /scorecard
---
<canvas id="gameCanvas" width="1200" height="900" style="position: relative; left: 245px; overflow: hidden; clip-path: inset(0 240px 0 0);"></canvas>
<input id="redNameInput" placeholder="RED CORNER" maxlength="20" class="hidden">
<input id="blueNameInput" placeholder="BLUE CORNER" maxlength="20" class="hidden">
<input id="eventNameInput" placeholder="#EVENT" maxlength="20" class="hidden">
<style>
    canvas { display: block; }
    input {
        position: absolute; 
        border: 1px solid #BBBBBB; 
        border-radius: 2px; 
        background: rgba(51, 51, 51, 0.3); 
        color: #F5F5F5; 
        font-family: GOBOLD, Impact, Verdana, sans-serif; 
        font-size: 28px;
        padding: 0; 
        line-height: 40px; 
        outline: none; 
        box-sizing: border-box;
        background-blend-mode: soft-light;
    }
    input::placeholder { color: rgba(245, 245, 245, 0.5); }
    #redNameInput { left: 296px; top: 31px; width: 320px; height: 40px; } /* 245 + 51 */
    #blueNameInput { left: 1076px; top: 31px; width: 320px; height: 40px; } /* 245 + 831 */
    #eventNameInput { left: 686px; top: 31px; width: 320px; height: 40px; } /* 441 + 245 */
    .hidden { display: none; }
    @font-face {
        font-family: 'GOBOLD';
        src: url('gobold.woff') format('woff');
    }
</style>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Constants
    const CANVAS_WIDTH = 1200; // Restored original width
    const CANVAS_HEIGHT = 900;
    const FPS = 60;
    const ROUND_TIME = 300;
    const INTERVAL_DURATION = 10;
    const SIDEBAR_WIDTH = 400;
    const PROGRESS_WIDTH = 1100; // Restored original width
    const ANIMATION_DURATION = 1.0;
    // Colors
    const BLACK = 'rgba(0, 0, 0, 0.7)';
    const WHITE = '#F5F5F5';
    const TRANSPARENT_WHITE = 'rgba(245, 245, 245, 0.5)';
    const RED = '#F6530F';
    const BLUE = '#1887C7';
    const GRAY = 'rgba(51, 51, 51, 0.7)';
    const LIGHT_GRAY = '#BBBBBB';
    const GREEN = '#00FF00';
    const TRANSPARENT_RED = 'rgba(246, 83, 15, 0.5)';
    const TRANSPARENT_BLUE = 'rgba(24, 135, 199, 0.5)';
    const TRANSPARENT_GRAY = 'rgba(255, 255, 255, 0.5)';
    const PROGRESS_START = '#00FFFF';
    const PROGRESS_MID = '#FF00FF';
    const PROGRESS_END = '#FFFF00';
    const PURPLE = 'rgba(128, 0, 128, 0.7)';
    const SHADE_WHITE = 'rgba(255, 255, 255, 0.1)';
    // Game variables
    let timerSeconds = ROUND_TIME;
    let timerRunning = false;
    let timerState = 'start';
    let pausedTime = 0;
    let currentRound = 1;
    let redScore = 0;
    let blueScore = 0;
    let redIntervalScore = 0;
    let blueIntervalScore = 0;
    let intervalTimer = 0;
    let intervals = [];
    let redName = '';
    let blueName = '';
    let eventName = '';
    let redNameInput = '';
    let blueNameInput = '';
    let eventNameInput = '#EVENT';
    let redNameLocked = false;
    let blueNameLocked = false;
    let eventNameLocked = false;
    let activeInput = null;
    let startTime = 0;
    let lastIntervalTime = 0;
    let roundLog = [];
    let roundLogFontSizes = [];
    let cursorVisible = true;
    let cursorTimer = 0;
    let sidebarOpen = false;
    let sidebarX = -SIDEBAR_WIDTH;
    let progressWidth = PROGRESS_WIDTH;
    let woodblockPlayed = false;
    let animationTime = 0;
    let needsRedraw = true;
    let copyButtonHover = false;
    // UI elements (shifted right by 240px to align with content area)
    const redNameRect = { x: 290, y: 30, width: 320, height: 40 }; // 50 + 240
    const blueNameRect = { x: 1070, y: 30, width: 320, height: 40 }; // 830 + 240
    const eventNameRect = { x: (610 + 830) / 2 - 160, y: 30, width: 320, height: 40 }; // Adjusted for 1200px
    const scoreRedRect = { x: 290, y: 100, width: 170, height: 45 }; // 50 + 240
    const scoreBlueRect = { x: CANVAS_WIDTH - 220, y: 100, width: 170, height: 45 };
    const logoRect = { x: 540, y: 130, width: 120, height: 32 }; // Centered within 1200px
    const timerRect = { x: CANVAS_WIDTH / 2 - 85, y: 170, width: 170, height: 50 };
    const roundLabelRect = { x: CANVAS_WIDTH / 2 - 50, y: 250, width: 100, height: 40 };
    const roundUpRect = { x: CANVAS_WIDTH / 2 + 90, y: 250, width: 40, height: 40 };
    const roundDownRect = { x: CANVAS_WIDTH / 2 - 140, y: 250, width: 40, height: 40 };
    const startButtonRect = { x: CANVAS_WIDTH / 2 - 190, y: 300, width: 170, height: 40 };
    const resetButtonRect = { x: CANVAS_WIDTH / 2 + 20, y: 300, width: 170, height: 40 };
    const progressRect = { x: 290, y: 350, width: CANVAS_WIDTH - 340, height: 10 }; // 50 + 240, adjusted width
    const graphRect = { x: 290, y: 360, width: CANVAS_WIDTH - 340, height: CANVAS_HEIGHT - 450 }; // 50 + 240, adjusted width
    const sidebarRect = { x: -SIDEBAR_WIDTH, y: 30, width: SIDEBAR_WIDTH, height: CANVAS_HEIGHT - 80 };
    const arrowRect = { x: 0, y: CANVAS_HEIGHT / 2 - 20, width: 40, height: 40 };
    const copyButtonRect = { x: 110, y: sidebarRect.height - 50, width: 180, height: 40 };
    // Load logo (ignored per user request)
    let logoImage = null;
    const loadLogo = new Promise((resolve) => {
        const img = new Image();
        img.src = 'logo.png';
        img.onload = () => {
            console.log('Matlock\'s Scorecard v3.14 - logo.png loaded successfully');
            resolve(img);
        };
        img.onerror = () => {
            console.error('Matlock\'s Scorecard v3.14 - Failed to load logo.png');
            resolve(null);
        };
    });
    // Audio setup
    let bellSound, woodblockSound, roundEndSound, buttonSound, enterSound, arrowSound, arrowKeySound;
    let audioInitialized = false;
    function generateSound(freq, duration, type = 'sine', amplitude = 1, noiseLevel = 0) {
        const sampleRate = audioCtx.sampleRate;
        const samples = Math.floor(sampleRate * duration);
        const buffer = audioCtx.createBuffer(1, samples, sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < samples; i++) {
            const t = i / sampleRate;
            let value = type === 'sine' ? Math.sin(2 * Math.PI * freq * t) : 0;
            if (noiseLevel > 0) value += (Math.random() * 2 - 1) * noiseLevel;
            value *= amplitude * Math.exp(-t * (type === 'pulse' ? 10 : 4) / duration);
            data[i] = value;
        }
        return buffer;
    }
    function playSound(buffer) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start();
    }
    function setupAudio() {
        bellSound = generateSound(800, 0.7, 'sine', 0.5);
        bellSound.getChannelData(0).forEach((v, i, arr) => {
            arr[i] += 0.5 * Math.sin(2 * Math.PI * 1200 * (i / audioCtx.sampleRate)) * Math.exp(-4 * (i / audioCtx.sampleRate) / 0.7);
        });
        const pulseDuration = 0.05;
        const spacing = 0.2;
        const pulseSamples = Math.floor(audioCtx.sampleRate * pulseDuration);
        const totalSamples = Math.floor(audioCtx.sampleRate * (pulseDuration * 3 + spacing * 2));
        const clackerBuffer = audioCtx.createBuffer(1, totalSamples, audioCtx.sampleRate);
        const clackerData = clackerBuffer.getChannelData(0);
        for (let i = 0; i < 3; i++) {
            const start = Math.floor(i * (pulseDuration + spacing) * audioCtx.sampleRate);
            for (let j = 0; j < pulseSamples; j++) {
                const t = j / audioCtx.sampleRate;
                const sine = Math.sin(2 * Math.PI * 1000 * t) * 0.7;
                const noise = (Math.random() * 2 - 1) * 0.3;
                clackerData[start + j] = (sine + noise) * 0.5 * Math.exp(-10 * t / pulseDuration);
            }
        }
        woodblockSound = clackerBuffer;
        roundEndSound = generateSound(600, 0.3, 'sine', 0.25);
        roundEndSound.getChannelData(0).forEach((v, i, arr) => {
            const t = i / audioCtx.sampleRate;
            arr[i] *= Math.exp(-4 * (t / 0.3) ** 2);
        });
        buttonSound = generateSound(800, 0.2, 'sine', 0.25, 0.2);
        enterSound = generateSound(1000, 0.25, 'sine', 0.25);
        arrowSound = generateSound(1200, 0.2, 'sine', 0.25);
        arrowKeySound = generateSound(1000, 0.1, 'sine', 0.125, 0.2);
        audioInitialized = true;
    }
    function sanitizeInput(text) {
        return text.toUpperCase().replace(/[<>&"']/g, '');
    }
    function drawText(text, fontSize, color, x, y, center = false) {
        ctx.font = `bold ${fontSize}px GOBOLD, Impact, Verdana, sans-serif`;
        ctx.fillStyle = color;
        ctx.textBaseline = 'top';
        if (center) {
            ctx.textAlign = 'center';
            ctx.fillText(text.toUpperCase(), x, y);
        } else {
            ctx.textAlign = 'left';
            ctx.fillText(text.toUpperCase(), x, y);
        }
    }
    function drawButton(text, rect, color, hover = false) {
        ctx.fillStyle = hover ? (text === 'COPY TO CLIPBOARD' && copyButtonHover ? GREEN : LIGHT_GRAY) : color;
        ctx.fillRect(rect.x - (hover ? 1 : 0), rect.y - (hover ? 1 : 0), rect.width + (hover ? 2 : 0), rect.height + (hover ? 2 : 0));
        ctx.strokeStyle = LIGHT_GRAY;
        ctx.lineWidth = 1;
        ctx.strokeRect(rect.x - (hover ? 1 : 0), rect.y - (hover ? 1 : 0), rect.width + (hover ? 2 : 0), rect.height + (hover ? 2 : 0));
        drawText(text, 14, WHITE, rect.x + rect.width / 2, rect.y + rect.height / 2 - 7, true);
    }
    function drawProgressBar() {
        ctx.fillStyle = PURPLE;
        ctx.fillRect(progressRect.x, progressRect.y, progressRect.width, progressRect.height);
        if (progressWidth > 0) {
            const gradient = ctx.createLinearGradient(progressRect.x, 0, progressRect.x + progressRect.width, 0);
            gradient.addColorStop(0, PROGRESS_START);
            gradient.addColorStop(0.5, PROGRESS_MID);
            gradient.addColorStop(1, PROGRESS_END);
            ctx.fillStyle = gradient;
            ctx.fillRect(progressRect.x, progressRect.y, progressWidth, progressRect.height);
        }
    }
    function drawGraph() {
        ctx.fillStyle = GRAY;
        ctx.fillRect(graphRect.x, graphRect.y, graphRect.width, graphRect.height);
        const intervalWidth = graphRect.width / (ROUND_TIME / INTERVAL_DURATION);
        const maxHeight = graphRect.height - 30;
        intervals.forEach((interval, i) => {
            const [red, blue] = interval;
            const x = graphRect.x + i * intervalWidth;
            let color, height;
            if (red > blue) {
                color = RED;
                height = red / (red + blue + 1) * maxHeight || 0;
            } else if (blue > red) {
                color = BLUE;
                height = blue / (red + blue + 1) * maxHeight || 0;
            } else {
                color = TRANSPARENT_GRAY;
                height = maxHeight / 4;
            }
            ctx.fillStyle = color;
            ctx.fillRect(x, graphRect.y + graphRect.height - height, intervalWidth - 2, height);
        });
        if (intervals.length * INTERVAL_DURATION < ROUND_TIME) {
            const x = graphRect.x + intervals.length * intervalWidth;
            let color, height;
            if (redIntervalScore > blueIntervalScore) {
                color = TRANSPARENT_RED;
                height = redIntervalScore / (redIntervalScore + blueIntervalScore + 1) * maxHeight || 0;
            } else if (blueIntervalScore > redIntervalScore) {
                color = TRANSPARENT_BLUE;
                height = blueIntervalScore / (redIntervalScore + blueIntervalScore + 1) * maxHeight || 0;
            } else {
                color = TRANSPARENT_GRAY;
                height = maxHeight / 4;
            }
            ctx.fillStyle = color;
            ctx.fillRect(x, graphRect.y + graphRect.height - height, intervalWidth - 2, height);
        }
        for (let i = ROUND_TIME; i >= 0; i -= 30) {
            const x = graphRect.x + (ROUND_TIME - i) * intervalWidth / INTERVAL_DURATION;
            drawText(`${Math.floor(i/60)}:${(i%60).toString().padStart(2, '0')}`, 14, WHITE, x, graphRect.y + graphRect.height + 5);
        }
    }
    function resetGame() {
        timerSeconds = ROUND_TIME;
        timerRunning = false;
        timerState = 'start';
        pausedTime = 0;
        currentRound = 1;
        redScore = 0;
        blueScore = 0;
        redIntervalScore = 0;
        blueIntervalScore = 0;
        intervalTimer = 0;
        intervals = [];
        redName = '';
        blueName = '';
        eventName = '';
        redNameInput = '';
        blueNameInput = '';
        eventNameInput = '#EVENT';
        redNameLocked = false;
        blueNameLocked = false;
        eventNameLocked = false;
        startTime = 0;
        lastIntervalTime = 0;
        roundLog = [];
        roundLogFontSizes.length = 0;
        cursorVisible = true;
        cursorTimer = 0;
        sidebarOpen = false;
        sidebarX = -SIDEBAR_WIDTH;
        progressWidth = PROGRESS_WIDTH;
        woodblockPlayed = false;
        copyButtonHover = false;
        document.getElementById('redNameInput').value = '';
        document.getElementById('blueNameInput').value = '';
        document.getElementById('eventNameInput').value = '#EVENT';
        document.getElementById('redNameInput').classList.add('hidden');
        document.getElementById('blueNameInput').classList.add('hidden');
        document.getElementById('eventNameInput').classList.add('hidden');
        needsRedraw = true;
    }
    function resetGraph() {
        intervals = [];
        redIntervalScore = 0;
        blueIntervalScore = 0;
        intervalTimer = 0;
        needsRedraw = true;
    }
    function resetTimer() {
        startTime = performance.now();
        lastIntervalTime = startTime;
        timerSeconds = ROUND_TIME;
        pausedTime = 0;
        progressWidth = PROGRESS_WIDTH;
        woodblockPlayed = false;
        needsRedraw = true;
    }
    async function copyToClipboard() {
        console.log(`Matlock's Scorecard v3.14 - roundLog:`, roundLog);
        const lines = [];
        let redPoints = 0, bluePoints = 0;
        for (let i = 0; i < roundLog.length; i++) {
            const log = roundLog[i];
            if (!log) {
                console.warn(`Matlock's Scorecard v3.14 - Empty roundLog entry at index ${i}`);
                continue;
            }
            const parts = log.split(', ');
            if (parts.length < 3) {
                console.warn(`Matlock's Scorecard v3.14 - Invalid roundLog format: ${log}`);
                continue;
            }
            const roundNumMatch = parts[0].match(/ROUND (\d+)/);
            if (!roundNumMatch) {
                console.warn(`Matlock's Scorecard v3.14 - Invalid round number in: ${log}`);
                continue;
            }
            const roundNum = roundNumMatch[1];
            let winner, score;
            if (parts[2] === 'DRAW') {
                winner = 'DRAW';
                score = '10-10';
                redPoints += 10;
                bluePoints += 10;
                lines.push(`ROUND ${roundNum}: ${score} ${winner}`);
            } else if (parts[2].includes('WINS')) {
                const winnerMatch = parts[2].match(/(.+?) WINS (.+)/);
                if (!winnerMatch) {
                    console.warn(`Matlock's Scorecard v3.14 - No winner found in: ${log}`);
                    continue;
                }
                winner = winnerMatch[1];
                score = winnerMatch[2];
                if (winner === (redName || 'RED CORNER')) {
                    redPoints += 10;
                    bluePoints += score === '10-9' ? 9 : 8;
                } else {
                    bluePoints += 10;
                    redPoints += score === '10-9' ? 9 : 8;
                }
                lines.push(`ROUND ${roundNum}: ${score} ${winner.toUpperCase()}`);
            } else {
                console.warn(`Matlock's Scorecard v3.14 - Invalid result in: ${log}`);
                continue;
            }
        }
        if (!lines.length && (redScore > 0 || blueScore > 0)) {
            const scoreDiff = Math.abs(redScore - blueScore);
            let score, winner;
            if (redScore === blueScore) {
                score = '10-10';
                winner = 'DRAW';
            } else if (redScore > blueScore) {
                score = scoreDiff > 25 ? '10-8' : '10-9';
                winner = redName || 'RED CORNER';
            } else {
                score = scoreDiff > 25 ? '10-8' : '10-9';
                winner = blueName || 'BLUE CORNER';
            }
            lines.push(`ROUND ${currentRound}: ${score} ${winner.toUpperCase()} ${eventName.toUpperCase() || '#EVENT'}`);
        }
        if (lines.length > 1) {
            if (currentRound < 5 && redPoints === bluePoints) {
                lines.push(`TOTAL: ${redPoints}-${bluePoints} GOING INTO THE ${currentRound + 1}${currentRound + 1 === 1 ? 'ST' : currentRound + 1 === 2 ? 'ND' : currentRound + 1 === 3 ? 'RD' : 'TH'} ${eventName.toUpperCase() || '#EVENT'}`);
            } else {
                const totalLine = redPoints >= bluePoints
                    ? `TOTAL: ${(redName || 'RED CORNER').toUpperCase()} ${redPoints}, ${(blueName || 'BLUE CORNER').toUpperCase()} ${bluePoints}`
                    : `TOTAL: ${(blueName || 'BLUE CORNER').toUpperCase()} ${bluePoints}, ${(redName || 'RED CORNER').toUpperCase()} ${redPoints}`;
                lines.push(totalLine + ` ${eventName.toUpperCase() || '#EVENT'}`);
            }
        } else if (lines.length === 1) {
            lines[0] = lines[0].endsWith(eventName.toUpperCase() || '#EVENT') ? lines[0] : `${lines[0]} ${eventName.toUpperCase() || '#EVENT'}`;
        }
        const text = lines.length ? lines.join('\n') : 'No rounds completed yet.';
        console.log(`Matlock's Scorecard v3.14 - Copying to clipboard: ${text}`);
        try {
            await navigator.clipboard.writeText(text);
            copyButtonHover = true;
            setTimeout(() => { copyButtonHover = false; needsRedraw = true; }, 500);
        } catch (err) {
            console.error('Matlock\'s Scorecard v3.14 - Clipboard access denied, using fallback:', err, 'Text:', text);
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                document.exec
